{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import RLP from \"rlp\";\nimport { Account, MPTProof, Node, TrieAccount } from \"./types\"\nimport { ethers, type BytesLike } from \"ethers\";\n\n\nfunction hexToBytes(hex: string) {\n    const bytes = [];\n    for (let c = 0; c < hex.length; c += 2)\n        bytes.push(parseInt(hex.substr(c, 2), 16));\n    return bytes;\n}\n\nfunction hexToBytesPadInverse(raw: string, length: number): number[] {\n  let bytes: number[] = hexToBytes(raw.substring(2)).map(e => e)\n  const _length = bytes.length\n  for (let index = 0; index < length - _length; index++)\n    if (index >= _length)\n      bytes = [0].concat(bytes)\n  return bytes\n}\n\n/* eslint-disable @typescript-eslint/no-unsafe-return*/\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction padArray(data: Array<any>, length: number) {\n  for (let index = data.length; index < length; index++) {\n    data.push(0)\n  }\n  return data\n}\n\n\nfunction encodeAccount(accountRaw:  Uint8Array[], address: string): TrieAccount {\n  console.log(\"before\")\n  console.log(accountRaw)\n  const account: Account = {\n    /* eslint-disable @typescript-eslint/no-unsafe-argument */\n    nonce: padArray(Array.from(accountRaw[0]!), 8),\n    balance: padArray(Array.from(accountRaw[1]!), 32),\n    nonce_length: accountRaw[0]!.length,\n    balance_length: accountRaw[1]!.length,\n    address: hexToBytesPadInverse(address, 20),\n    storage_hash: padArray(Array.from(accountRaw[2]!), 32),\n    code_hash: padArray(Array.from(accountRaw[3]!), 32),\n  }\n  const trie_key = hexToBytesPadInverse(ethers.keccak256(address), 32)\n  console.log(\"trie key:\")\n  console.log(trie_key)\n  return {\"account\": account, \"trie_key\": trie_key}\n}\n\nexport function getNodesFromProof(proof: BytesLike[], address: string): MPTProof {\n  const nodes: Node[] = []\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  let accountRaw: any\n  const roots: number[][] = []\n  console.log(\"proof:\")\n  console.log(proof)\n  for (let index = 0; index < proof.length; index++) {\n    const nodeRaw = proof[index];\n    roots.push(hexToBytesPadInverse(ethers.keccak256(nodeRaw!), 32))\n\n    const decoded = RLP.decode(nodeRaw)\n    let node_type: number\n    const rows: number[][] = []\n    const row_exist: number[] = []\n    let prefix_addition: number\n    if (decoded.length == 17) {\n      // branch\n      node_type = 0\n      prefix_addition = 1\n      let row_count = 0\n      console.log(\"injaaaa\")\n      console.log(decoded)\n      decoded.forEach(row => {\n        if (row instanceof Uint8Array) {\n          if (row_count != 16) {\n            let row_: number[] = []\n            if (row.length == 32) {\n                row_ = Array.from(row)\n                row_exist.push(1)\n            } else {\n                /* eslint-disable @typescript-eslint/no-unsafe-assignment */\n                row_ = Array(32).fill(0)\n                row_exist.push(0)\n            }\n            rows.push(row_)\n          }\n          row_count += 1\n        }\n      })\n    } else if (decoded.length == 2 && index != proof.length - 1) {\n      console.log(\"proof has a extension node!\")\n      node_type = 1\n      if (!(decoded[0] instanceof Uint8Array && decoded[1] instanceof Uint8Array))\n          throw Error(\"extension node has wrong format!\")\n      if (decoded[0].length == 0)\n          throw Error(\"extension node has wrong format!\")\n      const first_row: number[] = Array(32).fill(0)\n      first_row[0] = (decoded[0][0]! >> 4) & 0xF\n      first_row[1] = decoded[0][0]! & 0xF\n      first_row[2] = decoded[0].length - 1\n      rows.push(first_row)\n\n      const second_row: number[] = Array(32).fill(0)\n      for (let index = 0; index < first_row[2]; index++) {\n        second_row[index] = decoded[0][index + 1]!;\n      }\n      rows.push(second_row)\n\n      let third_row: number[] = []\n      decoded[1].map(e => third_row.push(e))\n      while (third_row.length != 32) {\n        third_row = [0].concat(third_row)\n      }\n      rows.push(third_row)\n\n      const zero: number[] = Array(32).fill(0)\n      for (let index = 0; index < 13; index++)\n        rows.push(zero)\n\n      for (let index = 0; index < 16; index++)\n        row_exist.push(0)\n\n      prefix_addition = first_row[2] * 2 + first_row[0]\n    } else {\n      console.log(\"leaf is here:\")\n      console.log(nodeRaw)\n      node_type = 2\n      \n      accountRaw = RLP.decode(RLP.decode(nodeRaw)[1])\n      prefix_addition = 0\n    }\n\n    const node_: Node = {\n        \"rows\": rows,\n        \"row_exist\": row_exist,\n        \"node_type\": node_type,\n        \"prefix_addition\": prefix_addition\n    }\n\n    if (node_type != 2) {\n      // if (index < nodes_initial_length)\n      //   nodes_initial.push(node_)\n      // else\n        nodes.push(node_)\n    }\n  }\n  // console.log(\"nodes initial\")\n  // console.log(nodes_initial)\n  console.log(\"nodes\")\n  console.log(nodes)\n  console.log(\"roots\")\n  console.log(roots)\n  const trie_account = encodeAccount(accountRaw, address)\n  return {nodes, roots, trie_account}\n}\n\nexport * from \"./types\""],"mappings":"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","names":["RLP","index"]}